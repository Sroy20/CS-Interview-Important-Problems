While preparing for the CS algorithms part of Machine Learning interviews, I came across many interesting problems. I have tried to list the ones that I have found to reappear quite a lot.

## Table of Contents

- [Primitive types](#primitive-types)
- [Arrays](#arrays)
- [Strings](#strings)
- [Linked Lists](#linked-lists)
- [Stacks and queues](#stacks-and-queues)
- [Binary trees](#binary-trees)
- [Heaps](#heaps)
- [Searching](#searching)
- [Hash tables](#hash-tables)
- [Sorting](#sorting)
- [Binary search trees](#binary-search-trees)
- [Recursion](#recursion)
- [Dynamic Programming](#dynamic-programming)
- [Greedy Algorithms and Invariants](#greedy-algorithms-and-invariants)

## Primitive types

## Arrays

## Strings

## Linked Lists

## Stacks and queues

## Binary trees

1. Check if two binary trees are identical
1. Write inorder traversal of a binary tree iteratively.
1. Write an Inorder Iterator for a Binary Tree.
1. Implement an inorder traversal with O(1) space
1. Test if a binary tree is height-balanced
1. Test if a binary tree is symmetric.
1. Compute the lowest common ancestor (LCA) in a binary tree
1. Compute the LCA when nodes have parent pointers
1. Display the node values at each level of a binary tree
1. Reconstruct a binary tree from traversal data
1. Reconctruct a binary tree from preorder traversal with markers
1. Compute the right sibling trees
1. Convert binary tree to doubly linked list
1. Print the perimeter of a binary tree
1. Given a binary tree, connect its siblings at each level
1. 

## Heaps

## Searching

## Hash tables

## Sorting

## Binary search trees

## Recursion

## Dynamic Programming

## Greedy Algorithms and Invariants

## Graphs

## Parallel Computing



