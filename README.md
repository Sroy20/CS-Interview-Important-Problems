While preparing for the CS algorithms part of Machine Learning interviews, I came across many interesting problems. I have tried to list the ones that I have found to reappear quite a lot.

## Table of Contents

- [Primitive types](#primitive-types)
- [Arrays](#arrays)
- [Strings](#strings)
- [Linked Lists](#linked-lists)
- [Stacks and queues](#stacks-and-queues)
- [Binary trees](#binary-trees)
- [Heaps](#heaps)
- [Searching](#searching)
- [Hash tables](#hash-tables)
- [Sorting](#sorting)
- [Binary search trees](#binary-search-trees)
- [Recursion](#recursion)
- [Dynamic Programming](#dynamic-programming)
- [Greedy Algorithms and Invariants](#greedy-algorithms-and-invariants)

## Primitive types

## Arrays

1. __The Dutch National Flag problem__: Write a program that takes an array _A_ and an index _i_ into _A_, and rearranges the elements such that all elements less than _A[i]_(the "pivot") appear first, followed by elements equal to the pivot, followed by elements greater than the pivot.
2. __Incerement an arbitrary-precision integer__: Write a program which takes as input an array of digits encoding a nonngetaive decimal integer _D_ and updates the array to represent the integer _D_+1. The algorithm should work even if implemented in a language that has finite-precision arithmetic.
3. __Multiply two arbitrary-precision integers__: Write a program that takes two arrays representing integers, and returns an integer representing their product. For example, since 193 x -761 = -146873, if the inputs are \[1, 9, 3] and \[-7, 6, 1], the function should return \[-1, 4, 6, 8, 7, 3]


## Strings

## Linked Lists



## Stacks and queues

## Binary trees

1. Test if a binary tree is height balanced
1. Test if a binary tree is symmetric
1. Compute the lowest common ancestor (LCA) in a binary tree
1. Compute the LCA when nodes have parent pointers
1. Sum the root-to-leaf paths in a binary tree
1. Find a root-to-leaf path with a specified sum
1. Implement an iorder traversal without recursion
1. Implement a preorder traversal without recursion
1. Compute the kth node in an inorder traversal
1. Compute the successor (Assume nodes have a parent field)
1. Implement an inorder traversal with O(1) space (Assume nodes have a parent field)
1. Reconstruct a binary tree from traversal data
1. Reconstruct a binary tree from preorder traversal with markers
1. Form a linked list from the leaves of a binary tree
1. Compute the exterior of a binary tree
1. Compute the right sibling tree
1. Check if two binary trees are identical
1. Level order traversal of a binary tree
1. Convert binary tree to doubly linked list
1. Serialize/Deserialize a binary tree
1. Connect all siblings in a binary tree
1. Mirror binary tree nodes
1. Delete zero sum sub-trees
1. N-ary tree to binary tree and back

## Heaps

## Searching

## Hash tables

## Sorting

## Binary search trees

## Recursion

## Dynamic Programming

## Greedy Algorithms and Invariants

## Graphs

## Parallel Computing



